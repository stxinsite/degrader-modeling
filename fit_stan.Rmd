---
title: "Fitting Stan"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(cmdstanr)
library(posterior)
library(bayesplot)
library(shinystan)
library(dplyr)
library(ggplot2)
```

```{r}
options(mc.cores=parallel::detectCores())
check_cmdstan_toolchain(fix = TRUE)
set_cmdstan_path("C:\\Users\\daniel.park\\.cmdstanr\\cmdstan-2.28.0")
```


# NANOBRET data processing
```{r}
nanobret_csv <- read.csv("data/corrected_nanobret_df.csv")

sorted_min <- sort(unique(nanobret_csv$Minutes))

# subtract min mBU within Construct group
nanobret_96 <- nanobret_csv %>% 
  filter(Minutes %in% sorted_min[6:7]) %>%
  group_by(Construct) %>%
  mutate(mBU_corrected = (mBU_corrected - min(mBU_corrected)) / 100 )

ggplot(nanobret_96, aes(x = uM, y = mBU_corrected, color = Construct)) +
  geom_point() +
  geom_line() +
  scale_x_log10()

nanobret_96 <- nanobret_96 %>% mutate(construct_int = recode(Construct,
  "VHL_WT SMARCA2_L1415S" = 1,
  "VHL_WT SMARCA2_E1420S" = 2,
  "VHL_R69Q SMARCA2_WT" = 1,
  "VHL_Y112F SMARCA2_WT" = 1,
  "VHL_WT SMARCA2_WT" = 2
))

ggplot(nanobret_96, aes(x = uM, y = mBU_corrected, color = as.factor(construct_int))) +
  geom_point() +
  scale_x_log10()

nanobret_96

```

# CMDSTAN

```{r}
register_knitr_engine(override = FALSE)
```


```{cmdstan, output.var="eq_model"}
functions {
  vector noncoop_sols(vector parms) {
    vector[3] sols;  // solutions [A], [C], [ABC] to non-cooperative equilibrium system

    real A_t = parms[1];
    real B_t = parms[2];
    real C_t = parms[3];
    real K_AB = parms[4];
    real K_BC = parms[5];
  
    real A = A_t - ((A_t + B_t + K_AB - sqrt(square(A_t + B_t + K_AB) - 4 * A_t * B_t)) / 2);
    real C = C_t - ((C_t + B_t + K_BC - sqrt(square(C_t + B_t + K_BC) - 4 * C_t * B_t)) / 2);
  
    real phi_AB = A_t - A;
    real phi_BC = C_t - C;
    real ABC;
    if (B_t == 0) {
      ABC = 1e-19;  // verify that root-finding transformation handles 0
    } else {
      ABC = phi_AB * phi_BC / B_t;
    }
    
    sols[1] = A;
    sols[2] = C;
    sols[3] = ABC;
    return sols;
  }
  
  vector system(vector y, vector theta, data real[] x_r, int[] x_i) {
    // y: unknown variables to solve for
    // theta: parameters [A]_t, [B]_t, [C]_t, alpha
    // x_r: data K_AB, K_BC
    // y_trans: f(y) = [A], [C], [ABC]
    // initial guesses y should be close to f-inv([A], [C], [ABC])
    vector[3] z;  // the system of mass-action equations
    vector[3] y_trans;  // transform y to constrain [A], [C], [ABC] >= 0
    real A;
    real C;
    real ABC;

    real A_t = theta[1];
    real B_t = theta[2];
    real C_t = theta[3];
    real alpha = theta[4];
    real K_AB = x_r[1];
    real K_BC = x_r[2];
    
    y_trans = square(y); 
    A = y_trans[1];
    C = y_trans[2];
    ABC = y_trans[3];

    z[1] = A + K_BC * ABC / (alpha * C) + ABC - A_t;
    z[2] = K_AB * K_BC * ABC / (alpha * A * C) + K_BC * ABC / (alpha * C) + K_AB * ABC / (alpha * A) + ABC - B_t;
    z[3] = C + K_AB * ABC / (alpha * A) + ABC - C_t;
    return z;
  }
}

data {
  int<lower=0> N;  // number of data points
  int<lower=1> N_construct;  // number of constructs
  real<lower=0> K_Ds[2];  // [K_AB, K_BC]
  vector<lower=0>[N] B_x;  // extracellular [B]_x
  int<lower=1> construct[N];  // array of integers identifying construct of row i
  vector<lower=0>[N] mBU;  // observed mBU
}

transformed data {
  int x_i[0];  // necessary for algebra_solver() call signature
  real<lower=0> kappa = 1;
  real<lower=0> log_beta = 0;
}

parameters {
  real<lower=0> C_t;  // total intracellular E3 concentration
  real<lower=0> A_t;  // total intracellular target protein concentration
  real<lower=1> alpha[N_construct];  // alpha[c] for each construct type c
  // real<lower=0, upper=1> kappa;
  // real log_beta;
  real<lower=0> sigma;  // error in mBU 
}

model {
  C_t ~ gamma(.001, .001);
  A_t ~ gamma(.001, .001);
  for (c in 1:N_construct) {
    alpha[c] ~ normal(30, 10); 
  }
  // kappa ~ uniform(0, 1);
  // log_beta ~ normal(0, 100);
  sigma ~ lognormal(0, 3); 
  
  for (i in 1:N) {
    real B_t;
    vector[3] noncoop_solutions;  // analytical non-cooperative solutions
    vector[3] y_init;  // transformed initial guess for y
    real alpha_c;  // cooperativity
    vector[4] theta;  // arguments for cooperative system root-finding
    vector[3] roots;  // roots to system
    vector[3] coop_solutions;  // transformed roots to cooperative system
    real predABC;  // predicted [ABC]
    real predmBU;  // predicted mBU
    
    B_t = B_x[i] * kappa;

    noncoop_solutions = noncoop_sols( [ A_t, B_t, C_t, K_Ds[1], K_Ds[2] ]' );
    y_init = sqrt(noncoop_solutions);

    theta = [ A_t, B_t, C_t, alpha[construct[i]] ]';  
    roots = algebra_solver_newton(system, y_init, theta, K_Ds, x_i);
    coop_solutions = square(roots); 

    predABC = coop_solutions[3];
    predmBU = predABC * exp(log_beta);

    mBU[i] ~ normal(predmBU, sigma);
  }
}
```

```{r}
# model data
stan_data <- list(
  N = nrow(nanobret_96),  # number of rows
  N_construct = length(unique(nanobret_96$construct_int)),  # number of constructs
  K_Ds = c(1.8, 0.25),  # K_Ds in uM
  B_x = nanobret_96$uM,  # extracellular [B]_x
  construct = nanobret_96$construct_int,  # construct index of row i
  mBU = nanobret_96$mBU_corrected  # observed mBU
)

inits_f <- function() {
  list(
    C_t = runif(1, min = 0, max = 5),
    A_t = runif(1, min = 0, max = 5),
    alpha = rnorm(stan_data$N_construct, mean = 30, sd = 5),
    # alpha = rnorm(5, mean = 30, sd = 1),
    # kappa = runif(1, min = 0.5, max = 1),
    # log_beta = runif(1, min = 0, max = 5),
    sigma = rgamma(n = 1, shape = 1, rate = 1)
  )
}
```

```{r}
eq_model$check_syntax()

eq_model$print()
```

```{r}
eq_fit <- eq_model$sample(data = stan_data, 
                          # seed = 0, 
                          refresh = 100, 
                          init = inits_f, 
                          iter_warmup = 1000, 
                          iter_sampling = 1000,
                          chains = 1,
                          # adapt_delta = 0.9
                          )
```

```{r}
eq_fit <- readRDS("eq_fit_nalpha_2.rds")
```

```{r}
eq_fit$cmdstan_diagnose()

eq_fit$summary()
```

```{r}
mcmc_areas(
  eq_fit$draws(), 
  pars = c("C_t", "A_t", "sigma"), 
  transformations = log, 
  prob = 0.8
  )

mcmc_areas(
  eq_fit$draws(), 
  regex_pars = "alpha*",
  prob = 0.8
  )

color_scheme_set("mix-blue-pink")
mcmc_trace(
  eq_fit$draws(), 
  pars = c("C_t", "A_t", "sigma"), 
  facet_args = list(nrow = 3)
)

mcmc_trace(
  eq_fit$draws(), 
  regex_pars = "alpha*",
  facet_args = list(nrow = 3)
)
```


```{r}
eq_fit$save_object(file = "eq_fit_nalpha_2.rds")
```


## PREDICT

```{r}
library(nleqslv)

equilibrium_f <- function(x, parms) {
  A_t <- parms[1]
  B_t <- parms[2]
  C_t <- parms[3]
  K_AB <- parms[4]
  K_BC <- parms[5]
  alpha <- parms[6]

  A <- exp(x[1])
  C <- exp(x[2])
  ABC <- exp(x[3])

  F1 <- A + K_BC * ABC / (alpha * C) + ABC - A_t
  F2 <- K_AB * K_BC * ABC / (alpha * A * C) + K_BC * ABC / (alpha * C) + K_AB * ABC / (alpha * A) + ABC - B_t
  F3 <- C + K_AB * ABC / (alpha * A) + ABC - C_t
  return(c(F1 = F1, F2 = F2, F3 = F3))
}

equilibrium_jac <- function(x, parms) {
  K_AB <- parms[4]
  K_BC <- parms[5]
  alpha <- parms[6]

  A <- exp(x[1])
  C <- exp(x[2])
  ABC <- exp(x[3])

  df_dy <- rbind(
    c(A, -K_BC * ABC / (alpha * C), K_BC * ABC / (alpha * C) + ABC),
    c(
      -K_AB * K_BC * ABC / (alpha * A * C) - K_AB * ABC / (alpha * A),
      -K_AB * K_BC * ABC / (alpha * A * C) - K_BC * ABC / (alpha * C),
      K_AB * K_BC * ABC / (alpha * A * C) + K_BC * ABC / (alpha * C) + K_AB * ABC / (alpha * A) + ABC
    ),
    c(-K_AB * ABC / (alpha * A), C, K_AB * ABC / (alpha * A) + ABC)
  )
  return(df_dy)
}

noncoop_f <- function(parms) {
  A_t <- parms[1]
  B_t <- parms[2]
  C_t <- parms[3]
  K_AB <- parms[4]
  K_BC <- parms[5]

  A <- A_t - (A_t + B_t + K_AB - sqrt((A_t + B_t + K_AB)**2 - 4 * A_t * B_t)) / 2
  C <- C_t - (C_t + B_t + K_BC - sqrt((C_t + B_t + K_BC)**2 - 4 * C_t * B_t)) / 2

  phi_AB <- A_t - A
  phi_BC <- C_t - C
  ABC <- ifelse(B_t == 0, 1e-19, phi_AB * phi_BC / B_t)
  return(c(A, C, ABC))
}

wrap_solve <- function(parms) {
  noncoop_sols <- noncoop_f(head(parms, -1))
  init_guess <- log(noncoop_sols)
  equilibrium_roots <- nleqslv(
    x = init_guess,
    fn = equilibrium_f,
    jac = equilibrium_jac,
    parms = parms
  )
  return(exp(equilibrium_roots$x[3]))
}

```

```{r}
A_t <- eq_fit$summary(variables = "A_t")[['mean']]
A_t <- .2
C_t <- eq_fit$summary(variables = "C_t")[['mean']]
alpha <- eq_fit$summary(variables = c("alpha[1]", "alpha[2]"))[['mean']]
B_x <- unique(nanobret_96$uM)

predmBU <- numeric(length(B_x) * stan_data$N_construct)
alpha_c <- numeric(length(predmBU))
for (i in 1:stan_data$N_construct) {
  for (j in 1:length(B_x)) {
    B_t <- B_x[j]
    predmBU[(i-1)*length(B_x) + j] <- wrap_solve(c(A_t, B_t, C_t, stan_data$K_Ds[1], stan_data$K_Ds[2], alpha[i]))
    alpha_c[(i-1)*length(B_x) + j] <- alpha[i]
  }
}

```

```{r}
fitted_df <- data.frame(
  uM = c(nanobret_96$uM, rep(B_x, stan_data$N_construct)),
  mBU = c(nanobret_96$mBU_corrected / 30, predmBU),
  Construct = c(nanobret_96$Construct, alpha_c),
  construct_int = c(nanobret_96$construct_int, rep(NA, length(predmBU)))
)

ggplot(fitted_df, aes(x = uM, y = mBU)) +
  geom_point(data = fitted_df %>% filter(substr(Construct, start = 1, stop = 1) == "V"),
             aes(color = factor(construct_int))) +
  geom_line(data = fitted_df %>% filter(substr(Construct, start = 1, stop = 1) != "V"),
             aes(color = Construct)) +
  scale_x_log10() 
```

## RSTAN

```{r}
# fit stan
fit_nanobret <- stan(file = "equilibrium.stan", 
                     data = stan_data,
                     # init = inits_f,
                     chains = 1,
                     iter = 2000,
                     cores = 1,
                     # control = list(adapt_delta = 0.9),
                     )
```

```{r}
# save stan_fit object
saveRDS(fit_nanobret, "fit_nanobret.rds")
```

```{r}
print(fit_nanobret)
```

```{r}
pairs(fit_nanobret)
plot(fit_nanobret)
traceplot(fit_nanobret)
```



# TEST STAN


```{r}
fit1 <- stan(file = "test_equilibrium.stan", algorithm = "Fixed_param", 
             data = list(N = nrow(nanobret_96),
                         N_construct = length(unique(nanobret_96$construct_int)),
                         K_Ds = c(1.8, .25),
                         B_x = nanobret_96$uM,
                         construct = nanobret_96$construct_int),
             iter = 1, chains = 1)
```

# TESTING RSTAN

```{r}
file <- file.path(cmdstan_path(), "examples", "bernoulli", "bernoulli.stan")
mod <- cmdstan_model(file) 
```
```{r}
mod$print()

# names correspond to the data block in the Stan program
data_list <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))

fit <- mod$sample(
  data = data_list,
  seed = 123,
  chains = 4,
  parallel_chains = 4,
  refresh = 500
)
```

```{r}
fit$summary()

```

