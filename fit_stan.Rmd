---
title: "Fitting Stan"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(cmdstanr)
library(posterior)
library(bayesplot)
library(shinystan)
library(dplyr)
library(ggplot2)
```

```{r}
options(mc.cores=parallel::detectCores())
```


# NANOBRET data processing
```{r}
nanobret_csv <- read.csv("data/corrected_nanobret_df.csv")

sorted_min <- sort(unique(nanobret_csv$Minutes))

# subtract min mBU within Construct group
nanobret_96 <- nanobret_csv %>% 
  filter(Minutes %in% sorted_min[6:7]) %>%
  group_by(Construct) %>%
  mutate(mBU_corrected = (mBU_corrected - min(mBU_corrected)) / 7)

ggplot(nanobret_96, aes(x = uM, y = mBU_corrected, color = Construct)) +
  geom_point() +
  geom_line() +
  scale_x_log10()

nanobret_96 <- nanobret_96 %>% mutate(construct_int = recode(Construct,
  "VHL_WT SMARCA2_L1415S" = 1,
  "VHL_WT SMARCA2_E1420S" = 2,
  "VHL_R69Q SMARCA2_WT" = 3,
  "VHL_Y112F SMARCA2_WT" = 4,
  "VHL_WT SMARCA2_WT" = 5
))

summary(nanobret_96)
```

# CMDSTAN

```{r}
register_knitr_engine(override = FALSE)
```


```{cmdstan, output.var="eq_model"}
functions {
  vector noncoop_sols(vector parms) {
    vector[3] sols;  // solutions [A], [C], [ABC] to non-cooperative equilibrium system

    real A_t = parms[1];
    real B_t = parms[2];
    real C_t = parms[3];
    real K_AB = parms[4];
    real K_BC = parms[5];
  
    real A = A_t - ((A_t + B_t + K_AB - sqrt(square(A_t + B_t + K_AB) - 4 * A_t * B_t)) / 2);
    real C = C_t - ((C_t + B_t + K_BC - sqrt(square(C_t + B_t + K_BC) - 4 * C_t * B_t)) / 2);
  
    real phi_AB = A_t - A;
    real phi_BC = C_t - C;
    real ABC;
    if (B_t == 0) {
      ABC = 0;  // verify that root-finding transformation handles 0
    } else {
      ABC = phi_AB * phi_BC / B_t;
    }
    
    sols[1] = A;
    sols[2] = C;
    sols[3] = ABC;
    return sols;
  }
  
  vector system(vector y, vector theta, data real[] x_r, int[] x_i) {
    // y: unknown variables to solve for
    // theta: parameters [A]_t, [B]_t, [C]_t, alpha
    // x_r: data K_AB, K_BC
    // y_trans: f(y) = [A], [C], [ABC]
    // initial guesses y should be close to f-inv([A], [C], [ABC])
    vector[3] z;  // the system of mass-action equations
    vector[3] y_trans;  // transform y to constrain [A], [C], [ABC] >= 0
    real A;
    real C;
    real ABC;

    real A_t = theta[1];
    real B_t = theta[2];
    real C_t = theta[3];
    real alpha = theta[4];
    real K_AB = x_r[1];
    real K_BC = x_r[2];
    
    y_trans = square(y);  // f(y) = y^2
    A = y_trans[1];
    C = y_trans[2];
    ABC = y_trans[3];

    z[1] = A + K_BC * ABC / (alpha * C) + ABC - A_t;
    z[2] = K_AB * K_BC * ABC / (alpha * A * C) + K_BC * ABC / (alpha * C) + K_AB * ABC / (alpha * A) + ABC - B_t;
    z[3] = C + K_AB * ABC / (alpha * A) + ABC - C_t;
    return z;
  }
}

data {
  int<lower=0> N;  // number of data points
  int<lower=1> N_construct;  // number of constructs
  real<lower=0> K_Ds[2];  // [K_AB, K_BC]
  vector<lower=0>[N] B_x;  // extracellular [B]_x
  int<lower=1> construct[N];  // array of integers identifying construct of row i
  vector<lower=0>[N] mBU;  // observed mBU
}

transformed data {
  int x_i[0];  // necessary for algebra_solver() call signature
  real<lower=0> kappa = 1;
  real<lower=0> beta = 1;
  real<lower=0> alpha[5] = {25., 30., 25., 25., 30.};
}

parameters {
  real<lower=0> C_t;  // total intracellular E3 concentration
  real<lower=0> A_t;  // total intracellular target protein concentration
  // real<lower=0> alpha[N_construct];  // alpha_c for each construct c
  // real<lower=0, upper=1> kappa;
  // real<lower=0> beta;
  real<lower=0> sigma;  // error in mBU 
}

transformed parameters {
  // real A_t = 0.4 * C_t;  // for now, set A_t deterministic
}

model {
  C_t ~ gamma(.001, .001);
  A_t ~ gamma(.001, .001);
  // for (j in 1:N_construct) {
  //   alpha[j] ~ normal(30, 5);  // mean = 30, sd = 5
  // }
  // kappa ~ uniform(0, 1);
  // beta ~ gamma(.001, .001);
  sigma ~ exponential(2); 
  
  print(C_t);
  print(A_t);
  print(A_t / C_t);

  for (i in 1:N) {
    real B_t;
    vector[3] noncoop_solutions;  // analytical non-cooperative solutions
    vector[3] y_init;  // transformed initial guess for y
    vector[4] theta;  
    vector[3] roots;
    vector[3] coop_solutions;
    real predmBU;
    
    B_t = B_x[i] * kappa;
    print(B_t);
    
    print(construct[i]);
    
    noncoop_solutions = noncoop_sols([A_t, B_t, C_t, K_Ds[1], K_Ds[2]]');
    y_init = sqrt(noncoop_solutions);
    print(square(y_init));
    
    theta = [A_t, B_t, C_t, alpha[construct[i]]]';  // arguments for cooperative system root-finding
    roots = algebra_solver_newton(system, y_init, theta, K_Ds, x_i);
    coop_solutions = square(roots); 
    print(coop_solutions);
    
    predmBU = coop_solutions[3] * beta;  // predicted mBU = ABC * beta

    // mBU[i] ~ normal(predmBU, sigma);
  }
}
```

```{r}
# model data
stan_data <- list(
  N = nrow(nanobret_96),  # number of rows
  N_construct = length(unique(nanobret_96$construct_int)),  # number of constructs
  K_Ds = c(1.8, .25),  # K_Ds in uM
  B_x = nanobret_96$uM,  # extracellular [B]_x
  construct = nanobret_96$construct_int,  # construct index of row i
  mBU = nanobret_96$mBU_corrected  # observed mBU
)

inits_f <- function() {
  C_t <- runif(1, min = 0, max = 10)
  
  list(
    # A_t = .4 * C_t,
    C_t = C_t,
    # alpha = rnorm(5, mean = 30, sd = 3),
    # kappa = runif(1, min = 0.5, max = 1),
    # beta = runif(1, min = 1, max = 5),
    sigma = rgamma(n = 1, shape = 1, rate = 1)
  )
}
```

```{r}
eq_model$check_syntax()

eq_model$print()

eq_fit <- eq_model$sample(data = stan_data, 
                          seed = 0, 
                          refresh = 10, 
                          # init = inits_f, 
                          chains = 1, 
                          iter_warmup = 10, 
                          iter_sampling = 10
                          )
```



```{r}
# fit stan
fit_nanobret <- stan(file = "equilibrium.stan", 
                     data = stan_data,
                     # init = inits_f,
                     chains = 1,
                     iter = 2000,
                     cores = 1,
                     # control = list(adapt_delta = 0.9),
                     )
```

```{r}
# save stan_fit object
saveRDS(fit_nanobret, "fit_nanobret.rds")
```

```{r}
print(fit_nanobret)
```

```{r}
pairs(fit_nanobret)
plot(fit_nanobret)
traceplot(fit_nanobret)
```



# TEST STAN


```{r}
fit1 <- stan(file = "test_equilibrium.stan", algorithm = "Fixed_param", 
             data = list(N = nrow(nanobret_96),
                         N_construct = length(unique(nanobret_96$construct_int)),
                         K_Ds = c(1.8, .25),
                         B_x = nanobret_96$uM,
                         construct = nanobret_96$construct_int),
             iter = 1, chains = 1)
```

# TESTING RSTAN

```{r}
file <- file.path(cmdstan_path(), "examples", "bernoulli", "bernoulli.stan")
mod <- cmdstan_model(file) 
```
```{r}
mod$print()

# names correspond to the data block in the Stan program
data_list <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))

fit <- mod$sample(
  data = data_list,
  seed = 123,
  chains = 4,
  parallel_chains = 4,
  refresh = 500
)
```

```{r}
fit$summary()

```

